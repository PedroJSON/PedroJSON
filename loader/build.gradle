//
// build.gradle for PedroJSON library
//

plugins {
    id 'com.android.library'
    id 'maven-publish'
    id 'signing'
}

group 'io.github.andersans11'

// Use environment variable for version (set by GitHub Actions) or fallback to default
def getVersionName = { ->
    // Try to get version from environment variable (GitHub release)
    def releaseVersion = System.getenv('RELEASE_VERSION')
    if (releaseVersion) {
        return releaseVersion
    }
    
    // Try to get version from Git tag
    try {
        def gitTag = 'git describe --tags --exact-match HEAD'.execute().text.trim()
        if (gitTag) {
            return gitTag.startsWith('v') ? gitTag.substring(1) : gitTag
        }
    } catch (Exception ignored) {
        // Fallback to default version
    }
    
    // Default version for local development
    return '1.0.4-alpha'
}

version getVersionName()
description 'A JSON-based path loading library for Pedro Pathing'

ext {
    PUBLISH_GROUP_ID = 'io.github.andersans11'
    PUBLISH_ARTIFACT_ID = 'pedrojson-loader'
    PUBLISH_VERSION = getVersionName()
}

android {
    compileSdkVersion 30

    defaultConfig {
        minSdkVersion 24
        //noinspection ExpiredTargetSdkVersion
        targetSdkVersion 28
        
        // Version info for the library
        versionCode 1
        versionName version
    }

    // Use the old namespace format to avoid R file generation issues
    packagingOptions {
        jniLibs.useLegacyPackaging true
    }
    
    // Configure build types
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    
    // Ensure Java 8 compatibility
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

repositories {
    mavenCentral()
    google()

    maven { url = 'https://maven.brott.dev/' }
    maven { url= "https://maven.pedropathing.com/" }

}

dependencies {
    annotationProcessor files('lib/OpModeAnnotationProcessor.jar')

    implementation 'org.firstinspires.ftc:Inspection:10.2.0'
    implementation 'org.firstinspires.ftc:Blocks:10.2.0'
    implementation 'org.firstinspires.ftc:RobotCore:10.2.0'
    implementation 'org.firstinspires.ftc:RobotServer:10.2.0'
    implementation 'org.firstinspires.ftc:OnBotJava:10.2.0'
    implementation 'org.firstinspires.ftc:Hardware:10.2.0'
    implementation 'org.firstinspires.ftc:FtcCommon:10.2.0'
    implementation 'org.firstinspires.ftc:Vision:10.2.0'
    compileOnly 'com.pedropathing:pedro:1.0.9'

    //noinspection GradleDependency
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'com.acmerobotics.dashboard:dashboard:0.4.16'

    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
    implementation 'com.fasterxml.jackson.core:jackson-core:2.15.2'
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.15.2'
    
    // Test dependencies
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:4.11.0'
    testImplementation 'com.pedropathing:pedro:1.0.9' // Available for tests
}

// Task to generate sources JAR
task androidSourcesJar(type: Jar) {
    archiveClassifier.set('sources')
    from android.sourceSets.main.java.srcDirs
}

// Task to generate Javadoc JAR (create empty one for now)
task androidJavadocsJar(type: Jar) {
    archiveClassifier.set('javadoc')
    // Create empty javadoc jar for now to satisfy Maven Central requirements
}

// Configure what gets published
artifacts {
    archives androidSourcesJar
    archives androidJavadocsJar
}

signing {
    // Get signing configuration
    def signingKeyAscii = System.getenv('SIGNING_KEY')
    def signingPasswordEnv = System.getenv('SIGNING_PASSWORD')
    def isGitHubActions = System.getenv('GITHUB_ACTIONS') != null
    def isCIEnvironment = isGitHubActions || System.getenv('CI') != null
    
    println "=== Signing Configuration Check ==="
    println "SIGNING_KEY present: ${signingKeyAscii != null && !signingKeyAscii.isEmpty()}"
    println "SIGNING_PASSWORD present: ${signingPasswordEnv != null && !signingPasswordEnv.isEmpty()}"
    println "CI Environment: ${isCIEnvironment}"
    println "GitHub Actions: ${isGitHubActions}"
    
    // Only configure signing when actually needed AND in appropriate environment
    required { 
        (gradle.taskGraph.hasTask("publishToCentralPortal") || gradle.taskGraph.hasTask("publishMavenPublicationToCentralPortalRepository")) &&
        isCIEnvironment // Only require signing in CI environments
    }
    
    // Configure signing only if environment variables are present AND in CI
    if (signingKeyAscii && signingPasswordEnv && isCIEnvironment) {
        println "üîë Configuring GPG signing for CI environment"
        
        try {
            def keyToUse = signingKeyAscii
            
            // Clean up the key format
            if (!keyToUse.contains("BEGIN PGP PRIVATE KEY BLOCK")) {
                // Try base64 decode
                try {
                    keyToUse = new String(Base64.getDecoder().decode(keyToUse))
                } catch (Exception e) {
                    println "Warning: Could not decode key as base64: ${e.message}"
                }
            }
            
            // Minimal key processing - normalize line endings only
            keyToUse = keyToUse.replaceAll("\\r\\n", "\\n").replaceAll("\\r", "\\n")
            
            // Ensure key ends with newline but don't modify content
            if (!keyToUse.endsWith("\\n")) {
                keyToUse += "\\n"
            }
            
            println "üîë Setting up in-memory PGP keys..."
            useInMemoryPgpKeys(keyToUse, signingPasswordEnv)
            println "‚úÖ GPG signing configured successfully"
            
        } catch (Exception e) {
            println "‚ùå Failed to configure GPG keys: ${e.message}"
            throw new GradleException("GPG signing configuration failed in CI environment: ${e.message}")
        }
    } else if (!isCIEnvironment) {
        println "‚ö†Ô∏è  Skipping signing configuration - not in CI environment (local development)"
        project.ext.skipSigning = true
    } else if (gradle.taskGraph.hasTask("publishToCentralPortal") || gradle.taskGraph.hasTask("publishMavenPublicationToCentralPortalRepository")) {
        throw new GradleException("GPG signing is required for Maven Central publishing but SIGNING_KEY and SIGNING_PASSWORD are not set")
    } else {
        println "‚ö†Ô∏è  Skipping signing configuration - environment variables not set"
    }
}

// Ensure publications are signed when signing is configured
afterEvaluate {
    def signingKeyAscii = System.getenv('SIGNING_KEY')
    def signingPasswordEnv = System.getenv('SIGNING_PASSWORD')
    def isCIEnvironment = System.getenv('GITHUB_ACTIONS') != null || System.getenv('CI') != null
    
    if (signingKeyAscii && signingPasswordEnv && isCIEnvironment && !project.hasProperty('skipSigning')) {
        println "üìù Configuring publication signing in CI environment..."
        signing {
            sign publishing.publications.maven
        }
        println "‚úÖ Publication signing configured"
    } else if (project.hasProperty('skipSigning')) {
        println "‚ö†Ô∏è  Skipping publication signing due to compatibility issues"
    } else {
        println "‚ÑπÔ∏è  Publication signing not needed (not in CI or missing credentials)"
    }
}

publishing {
    repositories {
        // GitHub Packages (for internal releases)
        maven {
            name = "GitHubPackages"
            url = uri("https://maven.pkg.github.com/pedrojson/PedroJSON")
            credentials {
                username = project.findProperty('gpr.user') ?: System.getenv('GITHUB_ACTOR')
                password = project.findProperty('gpr.key') ?: System.getenv('GITHUB_TOKEN')
            }
        }
        
        // Maven Central (Central Portal) - Bundle approach
        maven {
            name = "CentralPortal"
            url = layout.buildDirectory.dir("central-portal-bundle")
            // Local directory for bundle creation
        }
    }
    
    publications {
        // GitHub Packages publication
        gpr(MavenPublication) {
            groupId = PUBLISH_GROUP_ID
            artifactId = PUBLISH_ARTIFACT_ID
            version = PUBLISH_VERSION
            
            // Publish the release AAR
            afterEvaluate {
                from components.release
            }
            
            // Include sources and javadoc
            artifact androidSourcesJar
            artifact androidJavadocsJar
            
            pom {
                name = 'PedroJSON Loader'
                description = 'A JSON-based path loading library for Pedro Pathing'
                url = 'https://github.com/pedrojson/PedroJSON'
                
                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                        distribution = 'repo'
                    }
                }
                
                developers {
                    developer {
                        id = 'pedrojson'
                        name = 'PedroJSON Team'
                        email = 'aksandvick@icloud.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/pedrojson/PedroJSON.git'
                    developerConnection = 'scm:git:ssh://git@github.com/pedrojson/PedroJSON.git'
                    url = 'https://github.com/pedrojson/PedroJSON'
                }
            }
        }
        
        // Maven Central publication
        maven(MavenPublication) {
            groupId = PUBLISH_GROUP_ID
            artifactId = PUBLISH_ARTIFACT_ID
            version = PUBLISH_VERSION
            
            // Publish the release AAR
            afterEvaluate {
                from components.release
            }
            
            // Include sources and javadoc
            artifact androidSourcesJar
            artifact androidJavadocsJar
            
            pom {
                name = 'PedroJSON Loader'
                description = 'A JSON-based path loading library for Pedro Pathing'
                url = 'https://github.com/pedrojson/PedroJSON'
                
                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                        distribution = 'repo'
                    }
                }
                
                developers {
                    developer {
                        id = 'pedrojson'
                        name = 'PedroJSON Team'
                        email = 'aksandvick@icloud.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/pedrojson/PedroJSON.git'
                    developerConnection = 'scm:git:ssh://git@github.com/pedrojson/PedroJSON.git'
                    url = 'https://github.com/pedrojson/PedroJSON'
                }
                
                // Exclude FTC dependencies from runtime scope since they should be provided by the user's project
                withXml {
                    def dependenciesNode = asNode().dependencies[0]
                    dependenciesNode.dependency.each { dep ->
                        def groupId = dep.groupId[0].text()
                        if (groupId.startsWith('org.firstinspires.ftc') || groupId.contains('dashboard')) {
                            dep.scope[0].value = 'provided'
                        }
                    }
                }
            }
        }
    }
}

// Task to create Central Portal bundle and upload it
task publishToCentralPortal {
    dependsOn 'publishMavenPublicationToCentralPortalRepository'
    doLast {
        def bundleDir = file("$buildDir/central-portal-bundle")
        def zipFile = file("$buildDir/central-portal-bundle.zip")
        
        println "üì¶ Creating Central Portal bundle..."
        println "Bundle directory: ${bundleDir.absolutePath}"
        
        // Verify bundle directory exists
        if (!bundleDir.exists()) {
            throw new GradleException("‚ùå Bundle directory doesn't exist. Check that publishing completed successfully.")
        }
        
        // Find all files recursively in the bundle directory
        def allFiles = []
        bundleDir.eachFileRecurse { file ->
            if (file.isFile()) {
                allFiles << file
            }
        }
        
        println "üìã Bundle contents (${allFiles.size()} files):"
        allFiles.each { file ->
            def relativePath = bundleDir.toPath().relativize(file.toPath()).toString()
            println "   - ${relativePath} (${file.length()} bytes)"
        }
        
        if (allFiles.isEmpty()) {
            throw new GradleException("‚ùå No files found in bundle directory. Check that publishing completed successfully.")
        }
        
        // Verify required files are present
        def requiredExtensions = ['.pom', '.jar', '.aar']
        def requiredSignatures = ['.pom.asc', '.jar.asc', '.aar.asc']
        
        def hasRequiredFiles = requiredExtensions.every { ext ->
            allFiles.any { file -> file.name.endsWith(ext) }
        }
        
        def hasRequiredSignatures = requiredSignatures.every { ext ->
            allFiles.any { file -> file.name.endsWith(ext) }
        }
        
        if (!hasRequiredFiles) {
            println "‚ùå Missing required artifacts. Expected extensions: ${requiredExtensions}"
            println "Available files: ${allFiles.collect { it.name }.join(', ')}"
            throw new GradleException("‚ùå Missing required artifacts. Expected files with extensions: ${requiredExtensions}")
        }
        
        if (!hasRequiredSignatures) {
            println "‚ùå Missing required signatures. Expected extensions: ${requiredSignatures}"
            println "Available files: ${allFiles.collect { it.name }.join(', ')}"
            throw new GradleException("‚ùå Missing required signatures. Expected signature files: ${requiredSignatures}")
        }
        
        // Create ZIP bundle
        ant.zip(destfile: zipFile, basedir: bundleDir)
        println "‚úÖ Bundle created: ${zipFile.absolutePath} (${zipFile.length()} bytes)"
        
        // Upload to Central Portal
        def uploadUrl = "https://central.sonatype.com/api/v1/publisher/upload?publishingType=AUTOMATIC"
        def username = System.getenv('CENTRAL_PORTAL_USERNAME')
        def password = System.getenv('CENTRAL_PORTAL_PASSWORD')
        
        println "üîç Central Portal credentials check:"
        println "   Username: ${username ? 'SET (' + username.take(3) + '***)' : 'NOT SET'}"
        println "   Password: ${password ? 'SET (****)' : 'NOT SET'}"
        
        if (username && password) {
            println "ÔøΩ Uploading bundle to Central Portal..."
            
            try {
                // Use Gradle's HTTP client for better error handling
                def uploadCommand = [
                    'curl', '-v', '-X', 'POST',
                    '-u', "${username}:${password}",
                    '-H', 'User-Agent: PedroJSON-Gradle-Upload/1.0',
                    '-F', "bundle=@${zipFile.absolutePath}",
                    uploadUrl
                ]
                
                def process = uploadCommand.execute()
                def output = new StringBuilder()
                def error = new StringBuilder()
                
                process.consumeProcessOutput(output, error)
                process.waitFor()
                
                println "üìã Upload response:"
                println output.toString()
                
                if (process.exitValue() == 0) {
                    println "‚úÖ Successfully uploaded to Central Portal!"
                } else {
                    println "‚ùå Upload failed with exit code: ${process.exitValue()}"
                    println "Error output: ${error.toString()}"
                    throw new GradleException("Failed to upload to Central Portal")
                }
            } catch (Exception e) {
                println "‚ùå Upload exception: ${e.message}"
                throw new GradleException("Failed to upload to Central Portal: ${e.message}")
            }
        } else {
            throw new GradleException("‚ö†Ô∏è  Central Portal credentials not found. Set CENTRAL_PORTAL_USERNAME and CENTRAL_PORTAL_PASSWORD environment variables.")
        }
    }
}