//
// build.gradle for PedroJSON library
//

plugins {
    id 'com.android.library'
    id 'maven-publish'
    id 'signing'
}

group 'io.github.andersans11'

// Use environment variable for version (set by GitHub Actions) or fallback to default
def getVersionName = { ->
    // Try to get version from environment variable (GitHub release)
    def releaseVersion = System.getenv('RELEASE_VERSION')
    if (releaseVersion) {
        return releaseVersion
    }
    
    // Try to get version from Git tag
    try {
        def gitTag = 'git describe --tags --exact-match HEAD'.execute().text.trim()
        if (gitTag) {
            return gitTag.startsWith('v') ? gitTag.substring(1) : gitTag
        }
    } catch (Exception ignored) {
        // Fallback to default version
    }
    
    // Default version for local development
    return '1.0.4-alpha'
}

version getVersionName()
description 'A JSON-based path loading library for Pedro Pathing'

ext {
    PUBLISH_GROUP_ID = 'io.github.andersans11'
    PUBLISH_ARTIFACT_ID = 'pedrojson-loader'
    PUBLISH_VERSION = getVersionName()
}

android {
    compileSdkVersion 30

    defaultConfig {
        minSdkVersion 24
        //noinspection ExpiredTargetSdkVersion
        targetSdkVersion 28
        
        // Version info for the library
        versionCode 1
        versionName version
    }

    // Use the old namespace format to avoid R file generation issues
    packagingOptions {
        jniLibs.useLegacyPackaging true
    }
    
    // Configure build types
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    
    // Ensure Java 8 compatibility
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

repositories {
    mavenCentral()
    google()

    maven { url = 'https://maven.brott.dev/' }
    maven { url= "https://maven.pedropathing.com/" }

}

dependencies {
    annotationProcessor files('lib/OpModeAnnotationProcessor.jar')

    implementation 'org.firstinspires.ftc:Inspection:10.2.0'
    implementation 'org.firstinspires.ftc:Blocks:10.2.0'
    implementation 'org.firstinspires.ftc:RobotCore:10.2.0'
    implementation 'org.firstinspires.ftc:RobotServer:10.2.0'
    implementation 'org.firstinspires.ftc:OnBotJava:10.2.0'
    implementation 'org.firstinspires.ftc:Hardware:10.2.0'
    implementation 'org.firstinspires.ftc:FtcCommon:10.2.0'
    implementation 'org.firstinspires.ftc:Vision:10.2.0'
    compileOnly 'com.pedropathing:pedro:1.0.9'

    //noinspection GradleDependency
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'com.acmerobotics.dashboard:dashboard:0.4.16'

    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
    implementation 'com.fasterxml.jackson.core:jackson-core:2.15.2'
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.15.2'
    
    // Test dependencies
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:4.11.0'
    testImplementation 'com.pedropathing:pedro:1.0.9' // Available for tests
}

// Task to generate sources JAR
task androidSourcesJar(type: Jar) {
    archiveClassifier.set('sources')
    from android.sourceSets.main.java.srcDirs
}

// Task to generate Javadoc JAR (create empty one for now)
task androidJavadocsJar(type: Jar) {
    archiveClassifier.set('javadoc')
    // Create empty javadoc jar for now to satisfy Maven Central requirements
}

// Configure what gets published
artifacts {
    archives androidSourcesJar
    archives androidJavadocsJar
}

signing {
    // Only configure signing when actually needed
    required { gradle.taskGraph.hasTask("publishToCentralPortal") || gradle.taskGraph.hasTask("publishMavenPublicationToCentralPortalRepository") }
    
    // Get signing configuration
    def signingKeyAscii = System.getenv('SIGNING_KEY')
    def signingPasswordEnv = System.getenv('SIGNING_PASSWORD')
    
    println "=== Signing Configuration Check ==="
    println "SIGNING_KEY present: ${signingKeyAscii != null && !signingKeyAscii.isEmpty()}"
    println "SIGNING_PASSWORD present: ${signingPasswordEnv != null && !signingPasswordEnv.isEmpty()}"
    
    // Configure signing only if environment variables are present
    if (signingKeyAscii && signingPasswordEnv) {
        println "üîë Configuring GPG signing with environment variables"
        
        // Use a simple approach that avoids BouncyCastle issues during configuration
        project.ext.signingKey = signingKeyAscii
        project.ext.signingPassword = signingPasswordEnv
        
        // Defer the actual signing setup to when it's needed
        // Sign all publications when they're available
        
        println "‚úÖ GPG signing configuration deferred to execution time"
    } else {
        println "‚ö†Ô∏è  Skipping signing configuration - environment variables not set"
        if (gradle.taskGraph.hasTask("publishToCentralPortal") || gradle.taskGraph.hasTask("publishMavenPublicationToCentralPortalRepository")) {
            throw new GradleException("GPG signing is required for Maven Central publishing but SIGNING_KEY and SIGNING_PASSWORD are not set")
        }
    }
}

// Configure the actual signing when tasks are executed
gradle.taskGraph.whenReady {
    if (project.hasProperty('signingKey') && project.hasProperty('signingPassword')) {
        signing {
            try {
                def keyToUse = project.ext.signingKey
                def passwordToUse = project.ext.signingPassword
                
                println "üîë Setting up in-memory PGP keys for actual signing..."
                
                // Clean up the key format
                if (!keyToUse.contains("BEGIN PGP PRIVATE KEY BLOCK")) {
                    // Try base64 decode
                    try {
                        keyToUse = new String(Base64.getDecoder().decode(keyToUse))
                    } catch (Exception e) {
                        println "Warning: Could not decode key as base64: ${e.message}"
                    }
                }
                
                // Normalize line endings
                keyToUse = keyToUse.replaceAll("\\r\\n", "\\n").replaceAll("\\r", "\\n")
                if (!keyToUse.endsWith("\\n")) {
                    keyToUse += "\\n"
                }
                
                useInMemoryPgpKeys(keyToUse, passwordToUse)
                
                // Sign all available publications
                sign publishing.publications
                println "‚úÖ In-memory PGP keys configured successfully"
                
            } catch (Exception e) {
                println "‚ùå Failed to configure PGP keys: ${e.message}"
                throw e
            }
        }
    }
}

publishing {
    repositories {
        // GitHub Packages (for internal releases)
        maven {
            name = "GitHubPackages"
            url = uri("https://maven.pkg.github.com/pedrojson/PedroJSON")
            credentials {
                username = project.findProperty('gpr.user') ?: System.getenv('GITHUB_ACTOR')
                password = project.findProperty('gpr.key') ?: System.getenv('GITHUB_TOKEN')
            }
        }
        
        // Maven Central (Central Portal) - Bundle approach
        maven {
            name = "CentralPortal"
            url = layout.buildDirectory.dir("central-portal-bundle")
            // Local directory for bundle creation
        }
    }
    
    publications {
        // GitHub Packages publication
        gpr(MavenPublication) {
            groupId = PUBLISH_GROUP_ID
            artifactId = PUBLISH_ARTIFACT_ID
            version = PUBLISH_VERSION
            
            // Publish the release AAR
            afterEvaluate {
                from components.release
            }
            
            // Include sources and javadoc
            artifact androidSourcesJar
            artifact androidJavadocsJar
            
            pom {
                name = 'PedroJSON Loader'
                description = 'A JSON-based path loading library for Pedro Pathing'
                url = 'https://github.com/pedrojson/PedroJSON'
                
                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                        distribution = 'repo'
                    }
                }
                
                developers {
                    developer {
                        id = 'pedrojson'
                        name = 'PedroJSON Team'
                        email = 'aksandvick@icloud.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/pedrojson/PedroJSON.git'
                    developerConnection = 'scm:git:ssh://git@github.com/pedrojson/PedroJSON.git'
                    url = 'https://github.com/pedrojson/PedroJSON'
                }
            }
        }
        
        // Maven Central publication
        maven(MavenPublication) {
            groupId = PUBLISH_GROUP_ID
            artifactId = PUBLISH_ARTIFACT_ID
            version = PUBLISH_VERSION
            
            // Publish the release AAR
            afterEvaluate {
                from components.release
            }
            
            // Include sources and javadoc
            artifact androidSourcesJar
            artifact androidJavadocsJar
            
            pom {
                name = 'PedroJSON Loader'
                description = 'A JSON-based path loading library for Pedro Pathing'
                url = 'https://github.com/pedrojson/PedroJSON'
                
                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                        distribution = 'repo'
                    }
                }
                
                developers {
                    developer {
                        id = 'pedrojson'
                        name = 'PedroJSON Team'
                        email = 'aksandvick@icloud.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/pedrojson/PedroJSON.git'
                    developerConnection = 'scm:git:ssh://git@github.com/pedrojson/PedroJSON.git'
                    url = 'https://github.com/pedrojson/PedroJSON'
                }
                
                // Exclude FTC dependencies from runtime scope since they should be provided by the user's project
                withXml {
                    def dependenciesNode = asNode().dependencies[0]
                    dependenciesNode.dependency.each { dep ->
                        def groupId = dep.groupId[0].text()
                        if (groupId.startsWith('org.firstinspires.ftc') || groupId.contains('dashboard')) {
                            dep.scope[0].value = 'provided'
                        }
                    }
                }
            }
        }
    }
}

// Task to create Central Portal bundle and upload it
task publishToCentralPortal {
    dependsOn 'publishMavenPublicationToCentralPortalRepository'
    doLast {
        def bundleDir = file("$buildDir/central-portal-bundle")
        def zipFile = file("$buildDir/central-portal-bundle.zip")
        
        println "üì¶ Creating Central Portal bundle..."
        println "Bundle directory: ${bundleDir.absolutePath}"
        
        // Verify files exist in bundle
        if (!bundleDir.exists() || bundleDir.listFiles().length == 0) {
            throw new GradleException("‚ùå Bundle directory is empty or doesn't exist. Check that signing completed successfully.")
        }
        
        def files = bundleDir.listFiles()
        println "üìã Bundle contents:"
        files.each { file ->
            println "   - ${file.name} (${file.length()} bytes)"
        }
        
        // Verify required files are present
        def requiredExtensions = ['.pom', '.jar', '.aar']
        def requiredSignatures = ['.pom.asc', '.jar.asc', '.aar.asc']
        
        def hasRequiredFiles = requiredExtensions.every { ext ->
            files.any { file -> file.name.endsWith(ext) }
        }
        
        def hasRequiredSignatures = requiredSignatures.every { ext ->
            files.any { file -> file.name.endsWith(ext) }
        }
        
        if (!hasRequiredFiles) {
            throw new GradleException("‚ùå Missing required artifacts. Expected files with extensions: ${requiredExtensions}")
        }
        
        if (!hasRequiredSignatures) {
            throw new GradleException("‚ùå Missing required signatures. Expected signature files: ${requiredSignatures}")
        }
        
        // Create ZIP bundle
        ant.zip(destfile: zipFile, basedir: bundleDir)
        println "‚úÖ Bundle created: ${zipFile.absolutePath} (${zipFile.length()} bytes)"
        
        // Upload to Central Portal
        def uploadUrl = "https://central.sonatype.com/api/v1/publisher/upload?publishingType=AUTOMATIC"
        def username = System.getenv('CENTRAL_PORTAL_USERNAME')
        def password = System.getenv('CENTRAL_PORTAL_PASSWORD')
        
        println "üîç Central Portal credentials check:"
        println "   Username: ${username ? 'SET (' + username.take(3) + '***)' : 'NOT SET'}"
        println "   Password: ${password ? 'SET (****)' : 'NOT SET'}"
        
        if (username && password) {
            println "ÔøΩ Uploading bundle to Central Portal..."
            
            try {
                // Use Gradle's HTTP client for better error handling
                def uploadCommand = [
                    'curl', '-v', '-X', 'POST',
                    '-u', "${username}:${password}",
                    '-H', 'User-Agent: PedroJSON-Gradle-Upload/1.0',
                    '-F', "bundle=@${zipFile.absolutePath}",
                    uploadUrl
                ]
                
                def process = uploadCommand.execute()
                def output = new StringBuilder()
                def error = new StringBuilder()
                
                process.consumeProcessOutput(output, error)
                process.waitFor()
                
                println "üìã Upload response:"
                println output.toString()
                
                if (process.exitValue() == 0) {
                    println "‚úÖ Successfully uploaded to Central Portal!"
                } else {
                    println "‚ùå Upload failed with exit code: ${process.exitValue()}"
                    println "Error output: ${error.toString()}"
                    throw new GradleException("Failed to upload to Central Portal")
                }
            } catch (Exception e) {
                println "‚ùå Upload exception: ${e.message}"
                throw new GradleException("Failed to upload to Central Portal: ${e.message}")
            }
        } else {
            throw new GradleException("‚ö†Ô∏è  Central Portal credentials not found. Set CENTRAL_PORTAL_USERNAME and CENTRAL_PORTAL_PASSWORD environment variables.")
        }
    }
}